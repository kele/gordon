\documentclass{documentation}

\begin{document}
\begin{titlepage}
\begin{center}
Studencka Pracownia Inżynierii Oprogramowania\\
Instytutu Informatyki Uniwersytetu Wrocławskiego\\[6cm]

Damian Bogel, Łukasz Dąbek\\[1cm]
\textsc{\LARGE Kompilator Języka Gordon}\\[0.5cm]
\textsc{\large Architektura kompilatora}

\vfill
Wrocław 2013 \\[2.5cm]

\end{center}
\end{titlepage}

\newpage
\begin{table}
	\centering
	\caption{Historia zmian w dokumencie}
		\begin{tabular}{|r|c|c|l|l|}
		\hline
		Lp.  & Data       & Nr wersji & Autor                 & Zmiana \\ \hline
		1.   & 2013-10-22 & 0.01 & Łukasz Dąbek & Utworzenie dokumentu \\ \hline
	\end{tabular}
\end{table}
\newpage

\tableofcontents
\setcounter{page}{2}

\newpage

\section{Wstęp}
\noindent Niniejszy dokument nakreśla architekturę kompilatora języka \textsc{Gordon}. Mimo, że
w trakcie implementacji pewne szczegóły mogą ulec zmianie, to główna idea pozostanie
niezmieniona.

\section{Opis ogólnej architektury kompilatora}
\noindent Kompilator języka \textsc{Gordon} przetwarza plik wejściowy w następujących fazach:
\begin{itemize}
    \item analiza leksykalna i składniowa[G],
    \item inferencja i sprawdzanie typów [O1],
    \item eliminacja martwego kodu [R],
    \item wykrywanie zakleszczeń [D], 
    \item optymalizacja [O2],
    \item generacja kodu wynikowego [N].
\end{itemize}
W nawiasach kwadratowych podano nazwy poszczególnych modułów.

\subsection{Analiza leksykalna [G]}
\noindent Kod leksera jest generowany przy użyciu narzędzia \textsc{Flex}. Nietypową
częścią leksera jest uwzględnianie białych znaków w kodzie źródłowym jako symboli znaczących,
z racji tego, że struktura blokowa języka \textsc{Gordon} jest zdefiniowana przez poziomy wcięć.

\subsection{Analiza składniowa [G]}
\noindent Kod analizatora składniowego jest generowany przy użyciu narzędzia \textsc{Bison}.
Wynikiem działania modułu jest abstrakcyjne drzewo wyrażenia reprezentujące program wejściowy.
Następne fazy modyfikują to drzewo lub uzupełniają je o dodatkowe informacje.

\subsection{Inferencja i sprawdzanie typów [O1]}
\noindent Ponieważ język \textsc{Gordon} nie wymaga od programisty podawania typów wszystkich
zmiennych w kodzie źródłowym, potrzebny jest moduł inferencji typów, który na podstawie
programu odtwarza najogólniejszy typ danej zmiennej. Po udanej inferencji moduł sprawdzający
dokonuje sprawdzenia poprawności adnotacji typowych względem rzeczywistego użycia zmiennych
w programie.

\subsection{Eliminacja martwego kodu [R]}
\noindent Moduł służący do eliminacji martwego kodu służy do zmniejszenia rozmiaru pliku wynikowego
poprzez usunięcie kodu, który nie jest wywoływany przez główną ścieżkę wykonania programu.
Przy wykryciu martwego kodu zostanie wypisane stosowne ostrzeżenie dla programisty.

\subsection{Wykrywanie zakleszczeń [D]}
\noindent Moduł służący do wykrywania zakleszczeń jest najbardziej skomplikowaną częścią projektu
kompilatora języka \textsc{Gordon}. W przypadku, gdy kompilator nie jest w stanie wywnioskować
braku zakleszczeń w kompilowanym programie, zostanie zgłoszony błąd (domyślna opcja)
lub ostrzeżenie.

Dodatkowo, gdy moduł wykryje możliwość zakleszczenia, w niektórych przypadkach zostanie przedstawiony możliwy ślad wykonania prowadzący do zakleszczenia. 

\subsection{Optymalizacja [O]}
\noindent Optymalizacje wykonywane przez kompilator korzystają z dodatkowych informacji
niesionych przez typy języka \textsc{Gordon}, które są bardziej ekspresywne niż typy języka
wynikowego.
Optymalizacje niskopoziomowe (czyli korzystające ze szczegółów architektury docelowej) nie
są częścią modułu optymalizatora -- zadanie to zostanie oddelegowane do kompilatora języka \textsc{C}.

\subsection{Generacja kodu wynikowego [N]}
\noindent Generacja kodu wynikowego jest ostatnią fazą kompilacji. Podczaj tej fazy usuwane są
nadmiarowe informacje o typach a następnie wykonywane jest tłumaczenie kodu do kodu języka
\textsc{C} gotowego do dalszej kompilacji np. przy pomocy pakietu \textsc{GCC}.

\section{Kwestie implementacyjne}
\noindent Kompilator języka \textsc{Gordon} zostanie napisany w języku \textsc{OCaml}. W celu
zmniejszenia czasu implementacji w projekcie zostaną użyte darmowe biblioteki i programy o otwartym
kodzie źródłowym, takie jak: \textsc{Bison}, \textsc{Flex}, \textsc{make}.

\section{Motywacja decyzji architektonicznych}
\subsection{Wybór języka programowania}
\noindent Dojrzałość języka \textsc{OCaml}, w połączeniu z jego silnym systemem typów,
czyni go doskonałym wyborem do implementacji kompilatora. Dzięki tej
decyzji możliwe jest zmniejszenie liczby błędów w kodzie dzięki statycznemu
wymuszaniu niezmienników na poziomie typów.

\subsection{Wybór języka docelowego}
\noindent Język \textsc{C} został wybrany jako język docelowy kompilacji z kilku względów:
\begin{itemize}
    \item dostępność kompilatorów języka \textsc{C} na wielu platformach,
    \item możliwość wykorzystania instniejących, sprawdzonych narzędzi (konsolidatory,
        optymalizatory).
\end{itemize}

\subsection{Podział kompilacji na fazy}
\noindent Dzięki podziałowi kompilacji na fazy zyskujemy:
\begin{itemize}
    \item modularyzację kodu, a dzięki temu możliwość łatwej rozbudowy,
    \item łatwość oddzielnego testowania faz.
\end{itemize}

\end{document}
